{"version":3,"file":"mutation-rate-limiter.js","sourceRoot":"","sources":["../../../../src/extensions/replay/mutation-rate-limiter.ts"],"names":[],"mappings":"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","sourcesContent":["import type { eventWithTime, mutationCallbackParam } from '@rrweb/types'\nimport { INCREMENTAL_SNAPSHOT_EVENT_TYPE, MUTATION_SOURCE_TYPE } from './sessionrecording-utils'\nimport type { rrwebRecord } from './types/rrweb'\n\nimport { clampToRange } from '../../utils/number-utils'\n\nexport class MutationRateLimiter {\n    private bucketSize = 100\n    private refillRate = 10\n    private mutationBuckets: Record<string, number> = {}\n    private loggedTracker: Record<string, boolean> = {}\n\n    constructor(\n        private readonly rrweb: rrwebRecord,\n        private readonly options: {\n            bucketSize?: number\n            refillRate?: number\n            onBlockedNode?: (id: number, node: Node | null) => void\n        } = {}\n    ) {\n        this.refillRate = clampToRange(\n            this.options.refillRate ?? this.refillRate,\n            0,\n            100,\n            'mutation throttling refill rate'\n        )\n        this.bucketSize = clampToRange(\n            this.options.bucketSize ?? this.bucketSize,\n            0,\n            100,\n            'mutation throttling bucket size'\n        )\n        setInterval(() => {\n            this.refillBuckets()\n        }, 1000)\n    }\n\n    private refillBuckets = () => {\n        Object.keys(this.mutationBuckets).forEach((key) => {\n            this.mutationBuckets[key] = this.mutationBuckets[key] + this.refillRate\n\n            if (this.mutationBuckets[key] >= this.bucketSize) {\n                delete this.mutationBuckets[key]\n            }\n        })\n    }\n\n    private getNodeOrRelevantParent = (id: number): [number, Node | null] => {\n        // For some nodes we know they are part of a larger tree such as an SVG.\n        // For those we want to block the entire node, not just the specific attribute\n\n        const node = this.rrweb.mirror.getNode(id)\n\n        // Check if the node is an Element and then find the closest parent that is an SVG\n        if (node?.nodeName !== 'svg' && node instanceof Element) {\n            const closestSVG = node.closest('svg')\n\n            if (closestSVG) {\n                return [this.rrweb.mirror.getId(closestSVG), closestSVG]\n            }\n        }\n\n        return [id, node]\n    }\n\n    private numberOfChanges = (data: Partial<mutationCallbackParam>) => {\n        return (\n            (data.removes?.length ?? 0) +\n            (data.attributes?.length ?? 0) +\n            (data.texts?.length ?? 0) +\n            (data.adds?.length ?? 0)\n        )\n    }\n\n    public throttleMutations = (event: eventWithTime) => {\n        if (event.type !== INCREMENTAL_SNAPSHOT_EVENT_TYPE || event.data.source !== MUTATION_SOURCE_TYPE) {\n            return event\n        }\n\n        const data = event.data as Partial<mutationCallbackParam>\n        const initialMutationCount = this.numberOfChanges(data)\n\n        if (data.attributes) {\n            // Most problematic mutations come from attrs where the style or minor properties are changed rapidly\n            data.attributes = data.attributes.filter((attr) => {\n                const [nodeId, node] = this.getNodeOrRelevantParent(attr.id)\n\n                if (this.mutationBuckets[nodeId] === 0) {\n                    return false\n                }\n\n                this.mutationBuckets[nodeId] = this.mutationBuckets[nodeId] ?? this.bucketSize\n                this.mutationBuckets[nodeId] = Math.max(this.mutationBuckets[nodeId] - 1, 0)\n\n                if (this.mutationBuckets[nodeId] === 0) {\n                    if (!this.loggedTracker[nodeId]) {\n                        this.loggedTracker[nodeId] = true\n                        this.options.onBlockedNode?.(nodeId, node)\n                    }\n                }\n\n                return attr\n            })\n        }\n\n        // Check if every part of the mutation is empty in which case there is nothing to do\n        const mutationCount = this.numberOfChanges(data)\n\n        if (mutationCount === 0 && initialMutationCount !== mutationCount) {\n            // If we have modified the mutation count and the remaining count is 0, then we don't need the event.\n            return\n        }\n        return event\n    }\n}\n"]}