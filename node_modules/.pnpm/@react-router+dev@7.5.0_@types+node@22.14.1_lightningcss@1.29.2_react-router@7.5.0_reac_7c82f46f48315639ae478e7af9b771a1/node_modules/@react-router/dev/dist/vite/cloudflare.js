/**
 * @react-router/dev v7.5.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// vite/cloudflare.ts
var cloudflare_exports = {};
__export(cloudflare_exports, {
  cloudflareDevProxy: () => cloudflareDevProxyVitePlugin
});
module.exports = __toCommonJS(cloudflare_exports);

// vite/cloudflare-dev-proxy.ts
var import_react_router = require("react-router");

// vite/node-adapter.ts
var import_node_events = require("events");
var import_node_stream = require("stream");
var import_set_cookie_parser = require("set-cookie-parser");
var import_node = require("@react-router/node");

// invariant.ts
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    console.error(
      "The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose"
    );
    throw new Error(message);
  }
}

// vite/node-adapter.ts
function fromNodeHeaders(nodeReq) {
  let nodeHeaders = nodeReq.headers;
  if (nodeReq.httpVersionMajor >= 2) {
    nodeHeaders = { ...nodeHeaders };
    if (nodeHeaders[":authority"]) {
      nodeHeaders.host = nodeHeaders[":authority"];
    }
    delete nodeHeaders[":authority"];
    delete nodeHeaders[":method"];
    delete nodeHeaders[":path"];
    delete nodeHeaders[":scheme"];
  }
  let headers = new Headers();
  for (let [key, values] of Object.entries(nodeHeaders)) {
    if (values) {
      if (Array.isArray(values)) {
        for (let value of values) {
          headers.append(key, value);
        }
      } else {
        headers.set(key, values);
      }
    }
  }
  return headers;
}
function fromNodeRequest(nodeReq, nodeRes) {
  let origin = nodeReq.headers.origin && "null" !== nodeReq.headers.origin ? nodeReq.headers.origin : `http://${nodeReq.headers.host}`;
  invariant(
    nodeReq.originalUrl,
    "Expected `nodeReq.originalUrl` to be defined"
  );
  let url = new URL(nodeReq.originalUrl, origin);
  let controller = new AbortController();
  let init = {
    method: nodeReq.method,
    headers: fromNodeHeaders(nodeReq),
    signal: controller.signal
  };
  nodeRes.on("finish", () => controller = null);
  nodeRes.on("close", () => controller?.abort());
  if (nodeReq.method !== "GET" && nodeReq.method !== "HEAD") {
    init.body = (0, import_node.createReadableStreamFromReadable)(nodeReq);
    init.duplex = "half";
  }
  return new Request(url.href, init);
}
async function toNodeRequest(res, nodeRes) {
  nodeRes.statusCode = res.status;
  nodeRes.statusMessage = res.statusText;
  let cookiesStrings = [];
  for (let [name, value] of res.headers) {
    if (name === "set-cookie") {
      cookiesStrings.push(...(0, import_set_cookie_parser.splitCookiesString)(value));
    } else nodeRes.setHeader(name, value);
  }
  if (cookiesStrings.length) {
    nodeRes.setHeader("set-cookie", cookiesStrings);
  }
  if (res.body) {
    let responseBody = res.body;
    let readable = import_node_stream.Readable.from(responseBody);
    readable.pipe(nodeRes);
    await (0, import_node_events.once)(readable, "end");
  } else {
    nodeRes.end();
  }
}

// vite/vite.ts
var import_pathe2 = __toESM(require("pathe"));

// config/is-react-router-repo.ts
var import_pathe = __toESM(require("pathe"));
function isReactRouterRepo() {
  let serverRuntimePath = import_pathe.default.dirname(
    require.resolve("@react-router/node/package.json")
  );
  let serverRuntimeParentDir = import_pathe.default.basename(
    import_pathe.default.resolve(serverRuntimePath, "..")
  );
  return serverRuntimeParentDir === "packages";
}

// vite/vite.ts
var vite;
var viteImportSpecifier = isReactRouterRepo() ? (
  // Support testing against different versions of Vite by ensuring that Vite
  // is resolved from the current working directory when running within this
  // repo. If we don't do this, Vite will always be imported relative to this
  // file, which means that it will always resolve to Vite 6.
  `file:///${import_pathe2.default.normalize(
    require.resolve("vite/package.json", { paths: [process.cwd()] })
  ).replace("package.json", "dist/node/index.js")}`
) : "vite";
async function preloadVite() {
  vite = await import(viteImportSpecifier);
}
function getVite() {
  invariant(vite, "getVite() called before preloadVite()");
  return vite;
}

// config/config.ts
var import_node_fs = __toESM(require("fs"));
var import_node_child_process = require("child_process");
var import_package_json = __toESM(require("@npmcli/package-json"));

// vite/vite-node.ts
var import_server = require("vite-node/server");
var import_client = require("vite-node/client");
var import_source_map = require("vite-node/source-map");

// vite/ssr-externals.ts
var ssrExternals = isReactRouterRepo() ? [
  // This is only needed within this repo because these packages
  // are linked to a directory outside of node_modules so Vite
  // treats them as internal code by default.
  "react-router",
  "react-router-dom",
  "@react-router/architect",
  "@react-router/cloudflare",
  "@react-router/dev",
  "@react-router/express",
  "@react-router/node",
  "@react-router/serve"
] : void 0;

// vite/vite-node.ts
async function createContext({
  root,
  mode
}) {
  await preloadVite();
  const vite2 = getVite();
  const devServer = await vite2.createServer({
    root,
    mode,
    server: {
      preTransformRequests: false,
      hmr: false,
      watch: null
    },
    ssr: {
      external: ssrExternals
    },
    optimizeDeps: {
      noDiscovery: true
    },
    configFile: false,
    envFile: false,
    plugins: []
  });
  await devServer.pluginContainer.buildStart({});
  const server = new import_server.ViteNodeServer(devServer);
  (0, import_source_map.installSourcemapsSupport)({
    getSourceMap: (source) => server.getSourceMap(source)
  });
  const runner = new import_client.ViteNodeRunner({
    root: devServer.config.root,
    base: devServer.config.base,
    fetchModule(id) {
      return server.fetchModule(id);
    },
    resolveId(id, importer) {
      return server.resolveId(id, importer);
    }
  });
  return { devServer, server, runner };
}

// config/config.ts
var import_pathe3 = __toESM(require("pathe"));
var import_chokidar = __toESM(require("chokidar"));
var import_picocolors = __toESM(require("picocolors"));
var import_pick2 = __toESM(require("lodash/pick"));
var import_omit = __toESM(require("lodash/omit"));
var import_cloneDeep = __toESM(require("lodash/cloneDeep"));
var import_isEqual = __toESM(require("lodash/isEqual"));

// config/routes.ts
var Path = __toESM(require("pathe"));
var v = __toESM(require("valibot"));
var import_pick = __toESM(require("lodash/pick"));
function setAppDirectory(directory) {
  globalThis.__reactRouterAppDirectory = directory;
}
var routeConfigEntrySchema = v.pipe(
  v.custom((value) => {
    return !(typeof value === "object" && value !== null && "then" in value && "catch" in value);
  }, "Invalid type: Expected object but received a promise. Did you forget to await?"),
  v.object({
    id: v.optional(v.string()),
    path: v.optional(v.string()),
    index: v.optional(v.boolean()),
    caseSensitive: v.optional(v.boolean()),
    file: v.string(),
    children: v.optional(v.array(v.lazy(() => routeConfigEntrySchema)))
  })
);
var resolvedRouteConfigSchema = v.array(routeConfigEntrySchema);
function validateRouteConfig({
  routeConfigFile,
  routeConfig
}) {
  if (!routeConfig) {
    return {
      valid: false,
      message: `Route config must be the default export in "${routeConfigFile}".`
    };
  }
  if (!Array.isArray(routeConfig)) {
    return {
      valid: false,
      message: `Route config in "${routeConfigFile}" must be an array.`
    };
  }
  let { issues } = v.safeParse(resolvedRouteConfigSchema, routeConfig);
  if (issues?.length) {
    let { root, nested } = v.flatten(issues);
    return {
      valid: false,
      message: [
        `Route config in "${routeConfigFile}" is invalid.`,
        root ? `${root}` : [],
        nested ? Object.entries(nested).map(
          ([path4, message]) => `Path: routes.${path4}
${message}`
        ) : []
      ].flat().join("\n\n")
    };
  }
  return { valid: true };
}
function configRoutesToRouteManifest(appDirectory, routes, rootId = "root") {
  let routeManifest = {};
  function walk(route, parentId) {
    let id = route.id || createRouteId(route.file);
    let manifestItem = {
      id,
      parentId,
      file: Path.isAbsolute(route.file) ? Path.relative(appDirectory, route.file) : route.file,
      path: route.path,
      index: route.index,
      caseSensitive: route.caseSensitive
    };
    if (routeManifest.hasOwnProperty(id)) {
      throw new Error(
        `Unable to define routes with duplicate route id: "${id}"`
      );
    }
    routeManifest[id] = manifestItem;
    if (route.children) {
      for (let child of route.children) {
        walk(child, id);
      }
    }
  }
  for (let route of routes) {
    walk(route, rootId);
  }
  return routeManifest;
}
function createRouteId(file) {
  return Path.normalize(stripFileExtension(file));
}
function stripFileExtension(file) {
  return file.replace(/\.[a-z0-9]+$/i, "");
}

// config/config.ts
var excludedConfigPresetKeys = ["presets"];
var mergeReactRouterConfig = (...configs) => {
  let reducer = (configA, configB) => {
    let mergeRequired = (key) => configA[key] !== void 0 && configB[key] !== void 0;
    return {
      ...configA,
      ...configB,
      ...mergeRequired("buildEnd") ? {
        buildEnd: async (...args) => {
          await Promise.all([
            configA.buildEnd?.(...args),
            configB.buildEnd?.(...args)
          ]);
        }
      } : {},
      ...mergeRequired("future") ? {
        future: {
          ...configA.future,
          ...configB.future
        }
      } : {},
      ...mergeRequired("presets") ? {
        presets: [...configA.presets ?? [], ...configB.presets ?? []]
      } : {}
    };
  };
  return configs.reduce(reducer, {});
};
var deepFreeze = (o) => {
  Object.freeze(o);
  let oIsFunction = typeof o === "function";
  let hasOwnProp = Object.prototype.hasOwnProperty;
  Object.getOwnPropertyNames(o).forEach(function(prop) {
    if (hasOwnProp.call(o, prop) && (oIsFunction ? prop !== "caller" && prop !== "callee" && prop !== "arguments" : true) && o[prop] !== null && (typeof o[prop] === "object" || typeof o[prop] === "function") && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  return o;
};
function ok(value) {
  return { ok: true, value };
}
function err(error) {
  return { ok: false, error };
}
async function resolveConfig({
  root,
  viteNodeContext,
  reactRouterConfigFile
}) {
  let reactRouterUserConfig = {};
  if (reactRouterConfigFile) {
    try {
      if (!import_node_fs.default.existsSync(reactRouterConfigFile)) {
        return err(`${reactRouterConfigFile} no longer exists`);
      }
      let configModule = await viteNodeContext.runner.executeFile(
        reactRouterConfigFile
      );
      if (configModule.default === void 0) {
        return err(`${reactRouterConfigFile} must provide a default export`);
      }
      if (typeof configModule.default !== "object") {
        return err(`${reactRouterConfigFile} must export a config`);
      }
      reactRouterUserConfig = configModule.default;
    } catch (error) {
      return err(`Error loading ${reactRouterConfigFile}: ${error}`);
    }
  }
  reactRouterUserConfig = deepFreeze((0, import_cloneDeep.default)(reactRouterUserConfig));
  let presets = (await Promise.all(
    (reactRouterUserConfig.presets ?? []).map(async (preset) => {
      if (!preset.name) {
        throw new Error(
          "React Router presets must have a `name` property defined."
        );
      }
      if (!preset.reactRouterConfig) {
        return null;
      }
      let configPreset = (0, import_omit.default)(
        await preset.reactRouterConfig({ reactRouterUserConfig }),
        excludedConfigPresetKeys
      );
      return configPreset;
    })
  )).filter(function isNotNull(value) {
    return value !== null;
  });
  let defaults = {
    basename: "/",
    buildDirectory: "build",
    serverBuildFile: "index.js",
    serverModuleFormat: "esm",
    ssr: true
  };
  let {
    appDirectory: userAppDirectory,
    basename,
    buildDirectory: userBuildDirectory,
    buildEnd,
    prerender,
    serverBuildFile,
    serverBundles,
    serverModuleFormat,
    ssr
  } = {
    ...defaults,
    // Default values should be completely overridden by user/preset config, not merged
    ...mergeReactRouterConfig(...presets, reactRouterUserConfig)
  };
  if (!ssr && serverBundles) {
    serverBundles = void 0;
  }
  let isValidPrerenderConfig = prerender == null || typeof prerender === "boolean" || Array.isArray(prerender) || typeof prerender === "function";
  if (!isValidPrerenderConfig) {
    return err(
      "The `prerender` config must be a boolean, an array of string paths, or a function returning a boolean or array of string paths"
    );
  }
  let appDirectory = import_pathe3.default.resolve(root, userAppDirectory || "app");
  let buildDirectory = import_pathe3.default.resolve(root, userBuildDirectory);
  let rootRouteFile = findEntry(appDirectory, "root");
  if (!rootRouteFile) {
    let rootRouteDisplayPath = import_pathe3.default.relative(
      root,
      import_pathe3.default.join(appDirectory, "root.tsx")
    );
    return err(
      `Could not find a root route module in the app directory as "${rootRouteDisplayPath}"`
    );
  }
  let routes = {
    root: { path: "", id: "root", file: rootRouteFile }
  };
  let routeConfigFile = findEntry(appDirectory, "routes");
  try {
    if (!routeConfigFile) {
      let routeConfigDisplayPath = import_pathe3.default.relative(
        root,
        import_pathe3.default.join(appDirectory, "routes.ts")
      );
      return err(`Route config file not found at "${routeConfigDisplayPath}".`);
    }
    setAppDirectory(appDirectory);
    let routeConfigExport = (await viteNodeContext.runner.executeFile(
      import_pathe3.default.join(appDirectory, routeConfigFile)
    )).default;
    let routeConfig = await routeConfigExport;
    let result = validateRouteConfig({
      routeConfigFile,
      routeConfig
    });
    if (!result.valid) {
      return err(result.message);
    }
    routes = {
      ...routes,
      ...configRoutesToRouteManifest(appDirectory, routeConfig)
    };
  } catch (error) {
    return err(
      [
        import_picocolors.default.red(`Route config in "${routeConfigFile}" is invalid.`),
        "",
        error.loc?.file && error.loc?.column && error.frame ? [
          import_pathe3.default.relative(appDirectory, error.loc.file) + ":" + error.loc.line + ":" + error.loc.column,
          error.frame.trim?.()
        ] : error.stack
      ].flat().join("\n")
    );
  }
  let future = {
    unstable_middleware: reactRouterUserConfig.future?.unstable_middleware ?? false,
    unstable_optimizeDeps: reactRouterUserConfig.future?.unstable_optimizeDeps ?? false,
    unstable_splitRouteModules: reactRouterUserConfig.future?.unstable_splitRouteModules ?? false,
    unstable_subResourceIntegrity: reactRouterUserConfig.future?.unstable_subResourceIntegrity ?? false,
    unstable_viteEnvironmentApi: reactRouterUserConfig.future?.unstable_viteEnvironmentApi ?? false
  };
  let reactRouterConfig = deepFreeze({
    appDirectory,
    basename,
    buildDirectory,
    buildEnd,
    future,
    prerender,
    routes,
    serverBuildFile,
    serverBundles,
    serverModuleFormat,
    ssr
  });
  for (let preset of reactRouterUserConfig.presets ?? []) {
    await preset.reactRouterConfigResolved?.({ reactRouterConfig });
  }
  return ok(reactRouterConfig);
}
async function createConfigLoader({
  rootDirectory: root,
  watch
}) {
  root = root ?? process.env.REACT_ROUTER_ROOT ?? process.cwd();
  let viteNodeContext = await createContext({
    root,
    mode: watch ? "development" : "production"
  });
  let reactRouterConfigFile = findEntry(root, "react-router.config", {
    absolute: true
  });
  let getConfig = () => resolveConfig({ root, viteNodeContext, reactRouterConfigFile });
  let appDirectory;
  let initialConfigResult = await getConfig();
  if (!initialConfigResult.ok) {
    throw new Error(initialConfigResult.error);
  }
  appDirectory = initialConfigResult.value.appDirectory;
  let lastConfig = initialConfigResult.value;
  let fsWatcher;
  let changeHandlers = [];
  return {
    getConfig,
    onChange: (handler) => {
      if (!watch) {
        throw new Error(
          "onChange is not supported when watch mode is disabled"
        );
      }
      changeHandlers.push(handler);
      if (!fsWatcher) {
        fsWatcher = import_chokidar.default.watch(
          [
            ...reactRouterConfigFile ? [reactRouterConfigFile] : [],
            appDirectory
          ],
          { ignoreInitial: true }
        );
        fsWatcher.on("all", async (...args) => {
          let [event, rawFilepath] = args;
          let filepath = import_pathe3.default.normalize(rawFilepath);
          let appFileAddedOrRemoved = appDirectory && (event === "add" || event === "unlink") && filepath.startsWith(import_pathe3.default.normalize(appDirectory));
          let configCodeUpdated = Boolean(
            viteNodeContext.devServer?.moduleGraph.getModuleById(filepath)
          );
          if (configCodeUpdated || appFileAddedOrRemoved) {
            viteNodeContext.devServer?.moduleGraph.invalidateAll();
            viteNodeContext.runner?.moduleCache.clear();
          }
          if (appFileAddedOrRemoved || configCodeUpdated) {
            let result = await getConfig();
            let configChanged = result.ok && !(0, import_isEqual.default)(lastConfig, result.value);
            let routeConfigChanged = result.ok && !(0, import_isEqual.default)(lastConfig?.routes, result.value.routes);
            for (let handler2 of changeHandlers) {
              handler2({
                result,
                configCodeUpdated,
                configChanged,
                routeConfigChanged,
                path: filepath,
                event
              });
            }
            if (result.ok) {
              lastConfig = result.value;
            }
          }
        });
      }
      return () => {
        changeHandlers = changeHandlers.filter(
          (changeHandler) => changeHandler !== handler
        );
      };
    },
    close: async () => {
      changeHandlers = [];
      await viteNodeContext.devServer.close();
      await fsWatcher?.close();
    }
  };
}
async function loadConfig({ rootDirectory }) {
  let configLoader = await createConfigLoader({
    rootDirectory,
    watch: false
  });
  let config = await configLoader.getConfig();
  await configLoader.close();
  return config;
}
var entryExts = [".js", ".jsx", ".ts", ".tsx"];
function findEntry(dir, basename, options) {
  for (let ext of entryExts) {
    let file = import_pathe3.default.resolve(dir, basename + ext);
    if (import_node_fs.default.existsSync(file)) {
      return options?.absolute ?? false ? file : import_pathe3.default.relative(dir, file);
    }
  }
  return void 0;
}

// vite/cloudflare-dev-proxy.ts
var serverBuildId = "virtual:react-router/server-build";
function importWrangler() {
  try {
    return import("wrangler");
  } catch (_) {
    throw Error("Could not import `wrangler`. Do you have it installed?");
  }
}
var PLUGIN_NAME = "react-router-cloudflare-vite-dev-proxy";
var cloudflareDevProxyVitePlugin = (options = {}) => {
  let { getLoadContext, ...restOptions } = options;
  const workerdConditions = ["workerd", "worker"];
  let future;
  return {
    name: PLUGIN_NAME,
    config: async (config) => {
      await preloadVite();
      const vite2 = getVite();
      const serverConditions = [
        ...vite2.defaultServerConditions ?? []
      ];
      let configResult = await loadConfig({
        rootDirectory: config.root ?? process.cwd()
      });
      if (!configResult.ok) {
        throw new Error(configResult.error);
      }
      future = configResult.value.future;
      return {
        ssr: {
          resolve: {
            externalConditions: [...workerdConditions, ...serverConditions]
          }
        }
      };
    },
    configEnvironment: async (name, options2) => {
      if (!future.unstable_viteEnvironmentApi) {
        return;
      }
      if (name !== "client") {
        options2.resolve = options2.resolve ?? {};
        options2.resolve.externalConditions = [
          ...workerdConditions,
          ...options2.resolve?.externalConditions ?? []
        ];
      }
    },
    configResolved: (viteConfig) => {
      let pluginIndex = (name) => viteConfig.plugins.findIndex((plugin) => plugin.name === name);
      let reactRouterPluginIndex = pluginIndex("react-router");
      if (reactRouterPluginIndex >= 0 && reactRouterPluginIndex < pluginIndex(PLUGIN_NAME)) {
        throw new Error(
          `The "${PLUGIN_NAME}" plugin should be placed before the React Router plugin in your Vite config file`
        );
      }
    },
    configureServer: async (viteDevServer) => {
      let context;
      let getContext = async () => {
        let { getPlatformProxy } = await importWrangler();
        let { dispose, ...cloudflare } = await getPlatformProxy(
          restOptions
        );
        return { cloudflare };
      };
      return () => {
        if (!viteDevServer.config.server.middlewareMode) {
          viteDevServer.middlewares.use(async (nodeReq, nodeRes, next) => {
            try {
              let build = await viteDevServer.ssrLoadModule(
                serverBuildId
              );
              let handler = (0, import_react_router.createRequestHandler)(build, "development");
              let req = fromNodeRequest(nodeReq, nodeRes);
              context ??= await getContext();
              let loadContext = getLoadContext ? await getLoadContext({ request: req, context }) : context;
              let res = await handler(req, loadContext);
              await toNodeRequest(res, nodeRes);
            } catch (error) {
              next(error);
            }
          });
        }
      };
    }
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  cloudflareDevProxy
});
